# 多线程
## 基本概念
### 进程

进程是计算机中正在运行的程序的实例。每个进程都有自己独立的内存空间和系统资源，并且可以与其他进程并行执行。操作系统使用多任务调度器来管理进程，以使多个进程可以在同一时间内运行。

### 线程

线程是进程中的一个执行单元，每个进程可以有多个线程。线程与进程共享内存空间和系统资源，但它们可以同时独立运行，因为每个线程都有自己的程序计数器 （程序代码位置指针）和堆栈（存储局部变量和函数调用）。线程可以让多个任务在同一时间并行执行，从而提高计算机的效率。

从图像上看，进程就是一颗独立成树的大树，而线程就是这个大树上的子树。这样的关系使得程序在计算机中运行起来更为高效和灵活。

### 为什么使用多线程
+ 避免阻塞
> 大家知道，单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再去做其它的一些功能了。
+ 避免CPU空转
> 应用程序经常会涉及到RPC，数据库访问，磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差。  cpu 》》 内存 》》 磁盘
+ 提升效率
> 一个进程要独立拥有4GB的虚拟地址空间，而多个线程可以共享同一地址空间，线程的切换比进程的切换要快得多。

## 线程创建函数
### CreateThread()
CreateThread是一种微软在Windows API中提供了建立新的线程的函数，该函数在主线程的基础上创建一个新线程。线程终止运行后，线程对象仍然在系统中，必须通过CloseHandle函数来关闭该线程对象。
```
HANDLE CreateThread(
LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD
SIZE_T dwStackSize,//initialstacksize
LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction
LPVOID lpParameter,//threadargument
DWORD dwCreationFlags,//creationoption
LPDWORD lpThreadId//threadidentifier
)
```
+ 第一个参数 lpThreadAttributes 表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。
+ 第二个参数 dwStackSize 表示线程栈空间大小。传入0表示使用默认大小（1MB）。
+ 第三个参数 lpStartAddress 表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。
+ 第四个参数 lpParameter 是传给线程函数的参数。
+ 第五个参数 dwCreationFlags 指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。
+ 第六个参数 lpThreadId 将返回线程的ID号，传入NULL表示不需要返回该线程ID号

### _beginthreadex()
```c++
  unsigned long _beginthreadex(
  
    void *security,    // 安全属性， 为NULL时表示默认安全性
 
    unsigned stack_size,    // 线程的堆栈大小， 一般默认为0
 
    unsigned(_stdcall *start_address)(void *),   // 线程函数
 
    void *argilist, // 线程函数的参数
 
   unsigned initflag,    // 新线程的初始状态，0表示立即执行，//CREATE_SUSPENDED表示创建之后挂起
    unsigned *threaddr    // 用来接收线程ID
 
);
```
返回值 : // 成功返回新线程句柄， 失败返回0

__stdcall表示

1.参数从右向左压入堆栈

2.函数被调用者修改堆栈

### 区别
1. 参数不同：_beginthreadex()需要指定堆栈的大小和初始的线程栈指针，而CreateThread()不需要。

2. 句柄不同：_beginthreadex()返回一个无符号整数线程ID，而CreateThread()返回一个句柄。

3. 功能不同：_beginthreadex()是为了支持C++对象，只有C++能使用，而CreateThread()可以使用在任何环境下。

4. 安全性不同：_beginthreadex()相比CreateThread()较为安全，因为它在创建多线程之前设置了CRT线程初始化代码。

## 内核对象 
### 定义
内核对象通过API来创建，每个内核对象是一个数据结构，它对应一块内存，由操作系统内核分配，并且只能由操作系统内核访问。在此数据结构中少数成员如安全描述符和使用计数是所有对象都有的，但其他大多数成员都是不同类型的对象特有的。内核对象的数据结构只能由操作系统提供的API访问，应用程序在内存中不能访问。调用创建内核对象的函数后，该函数会返回一个句柄，它标识了所创建的对象。它可以由进程的任何线程使用。

Windows中每个内核对象都只是一个**内存块**，它由**操作系统内核分配**，并只能由**操作系统内核进行访问**，应用程序不能在内存中定位这些数据结构并直接更改其内容。这个**内存块是一个数据结构**，其成员维护着与对象相关的信息。**少数成员（安全描述符和使用计数）是所有内核对象都有的**，但大多数成员都是不同类型对象特有的。

常见的内核对象 : 进程、线程、文件，存取符号对象、事件对象、文件对象、作业对象、互斥对象、管道对象、等待计时器对象，邮件槽对象，信号对象

内核对象：为了管理线程/文件等资源而由操作系统创建的数据块。其创建的所有者肯定是操作系统。

### WaitForSingleObject
来等待一个内核对象变为已通知状态
```
WaitForSingleObject(
_In_ HANDLE hHandle,    //指明一个内核对象的句柄
_In_ DWORD dwMilliseconds     //等待时间
);
```
### WaitForMultipleObjects  
等待内核对象变为已通知状态
```
WaitForMultipleObjects(
_In_ DWORD nCount,    // 要监测的句柄的组的句柄的个数
_In_reads_(nCount) CONST HANDLE* lpHandles,   //要监测的句柄的组
_In_ BOOL bWaitAll,  // TRUE 等待所有的内核对象发出信号，FALSE 任意一个内核对象发出信号
_In_ DWORD dwMilliseconds //等待时间
);
```
## 线程同步
### 互斥对象
互斥对象(mutex)属于内核对象，它能够确保线程拥有对单个资源的互斥访问权。

互斥对象包含一个使用数量，一个线程ID和一个计数器。其中线程ID用于标识系统中的哪个线程当前拥有互斥对象，计数器用于指明该线程拥有互斥对象的次数。

#### 创建互斥对象：
调用函数CreateMutex。调用成功，该函数返回所创建的互斥对象的句柄。
```
CreateMutex
HANDLE
WINAPI
CreateMutexW(
    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,   //指向安全属性
    _In_ BOOL bInitialOwner,   //初始化互斥对象的所有者  TRUE 立即拥有互斥体，false表示创建的这个mutex不属于任何线程；所以处于激发状态，也就是有信号状态
    _In_opt_ LPCWSTR lpName    //指向互斥对象名的指针  L“Bingo”
    );
```
#### 请求互斥对象所有权：
调用函数WaitForSingleObject函数。线程必须主动请求共享对象的所有权才能获得所有权。
#### 释放指定互斥对象的所有权：
调用ReleaseMutex函数。线程访问共享资源结束后，线程要主动释放对互斥对象的所有权，使该对象处于已通知状态。

### 事件对象
事件对象也属于内核对象，它包含以下三个成员：
+ 使用计数；
+ 用于指明该事件是一个自动重置的事件还是一个人工重置的事件的布尔值；
+ 用于指明该事件处于已通知状态还是未通知状态的布尔值。

事件对象有两种类型：人工重置的事件对象和自动重置的事件对象。这两种事件对象的区别在于

当人工重置的事件对象得到通知时，等待该事件对象的所有线程均变为可调度线程；

而当一个自动重置的事件对象得到通知时，等待该事件对象的线程中只有一个线程变为可调度线程。
#### 创建事件对象
调用CreateEvent函数创建或打开一个命名的或匿名的事件对象。
```
HANDLE CreateEvent( 　　
LPSECURITY_ATTRIBUTES lpEventAttributes, // 安全属性 　　
BOOL bManualReset, 　　// 复位方式　　TRUE 必须用ResetEvent手动复原  FALSE 自动还原为无信号状态
BOOL bInitialState, 　 // 初始状态 　　TRUE 初始状态为有信号状态  FALSE 无信号状态
LPCTSTR lpName 　　　　//对象名称 　NULL  无名的事件对象　
);
```

#### 设置事件对象状态
调用SetEvent函数把指定的事件对象设置为有信号状态。

#### 重置事件对象状态
调用ResetEvent函数把指定的事件对象设置为无信号状态。

#### 请求事件对象
线程通过调用WaitForSingleObject函数请求事件对象。
