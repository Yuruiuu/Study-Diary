# 1
1.对于下面代码段char *const name = new char[5];下面的语句中正确的是（）

A、name[3]='q'；

B、name="line";

C、name=new char[5];

D、name=new char('q');

解析：

name被定义常量指针，所以它所指的内容能改变，但指针本身的内容不可以修改。

name[3]='q'；"修改了name所指的内容，是正确的。

而"name="line"；"name= new char[5]；"和"name=new char（'q'）；"以不同的方法修改了常量指针，都是错误的。

# 2
2.【多选】以下哪些做法是不正确或者应该极力避免的：（ ）

A、构造函数声明为虚函数

B、派生关系中的基类析构函数声明为虚函数

C、构造函数中调用虚函数

D、析构函数中调用虚函数

解析：答案为：A、C、D。

+ 先析构子类再析构父类，如果父类析构函数有虚函数，会导致调用子类的已经析构的内容。

+ 先构造父亲类再构造子类，如果父类构造函数有虚函数，会导致调用子类还没构造的内容。

A选项：构造函数声明为虚函数，是不正确的做法。构造函数主要用于初始化对象的状态，而虚函数是在运行时动态绑定的，需要通过对象的虚函数表来查找实际需要调用的函数。

而对象的虚函数表在构造函数还没有执行完毕之前是无法初始化的，因此构造函数不能声明为虚函数。

B选项：派生关系中的基类析构函数声明为虚函数是正确的做法，这样就可以通过基类指针来正确地调用派生类对象的析构函数。

C选项：构造函数中调用虚函数是不正确的做法。在构造函数执行期间，对象尚未完全构造完成，只有当前类的成员变量已经初始化，而派生类的成员变量尚未初始化。

如果在构造函数中调用虚函数，会导致调用错误的函数或出现未定义的行为。

D选项：析构函数中调用虚函数是不正确的做法。对象的析构函数被调用时，对象已经开始撤销，即成员变量逐步被销毁，如果在析构函数中调用虚函数，

可能会调用当前对象已经被销毁的虚函数，引发未定义的行为。

# 3

执行如下代码后输出结果为（）
```c++
int main() {
    int a[5]  = {1, 2, 3, 4, 5};
    int *ptr = (int*)(&a + 1);
    printf("%d, %d", *(a + 1), *(ptr - 1));
    return 0;
}
```
A 11

B 1,3

C 3,3

D 2,5

解析：

&a + 1，其中 + 1 偏移的大小为 a 整个数组的大小，即 5 个 int 型的大小；

a + 1，其中 + 1 偏移的大小为 a 中一个元素的大小，即 1 个 int 型的大小；

ptr - 1，由于强制类型转换，此时 - 1 偏移的大小为 1 个 int 型；

# 4
如果MyClass为一个类，执行”MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是()
A 2

B 5

C 4

D 9

解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，

但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。
