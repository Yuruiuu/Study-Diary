# 1
1.对于下面代码段char *const name = new char[5];下面的语句中正确的是（）

A、name[3]='q'；

B、name="line";

C、name=new char[5];

D、name=new char('q');

解析：

name被定义常量指针，所以它所指的内容能改变，但指针本身的内容不可以修改。

name[3]='q'；"修改了name所指的内容，是正确的。

而"name="line"；"name= new char[5]；"和"name=new char（'q'）；"以不同的方法修改了常量指针，都是错误的。

# 2
2.【多选】以下哪些做法是不正确或者应该极力避免的：（ ）

A、构造函数声明为虚函数

B、派生关系中的基类析构函数声明为虚函数

C、构造函数中调用虚函数

D、析构函数中调用虚函数

解析：答案为：A、C、D。

+ 先析构子类再析构父类，如果父类析构函数有虚函数，会导致调用子类的已经析构的内容。

+ 先构造父亲类再构造子类，如果父类构造函数有虚函数，会导致调用子类还没构造的内容。

A选项：构造函数声明为虚函数，是不正确的做法。构造函数主要用于初始化对象的状态，而虚函数是在运行时动态绑定的，需要通过对象的虚函数表来查找实际需要调用的函数。

而对象的虚函数表在构造函数还没有执行完毕之前是无法初始化的，因此构造函数不能声明为虚函数。

B选项：派生关系中的基类析构函数声明为虚函数是正确的做法，这样就可以通过基类指针来正确地调用派生类对象的析构函数。

C选项：构造函数中调用虚函数是不正确的做法。在构造函数执行期间，对象尚未完全构造完成，只有当前类的成员变量已经初始化，而派生类的成员变量尚未初始化。

如果在构造函数中调用虚函数，会导致调用错误的函数或出现未定义的行为。

D选项：析构函数中调用虚函数是不正确的做法。对象的析构函数被调用时，对象已经开始撤销，即成员变量逐步被销毁，如果在析构函数中调用虚函数，

可能会调用当前对象已经被销毁的虚函数，引发未定义的行为。

# 3

执行如下代码后输出结果为（）
```c++
int main() {
    int a[5]  = {1, 2, 3, 4, 5};
    int *ptr = (int*)(&a + 1);
    printf("%d, %d", *(a + 1), *(ptr - 1));
    return 0;
}
```
A 11

B 1,3

C 3,3

D 2,5

解析：

&a + 1，其中 + 1 偏移的大小为 a 整个数组的大小，即 5 个 int 型的大小；

a + 1，其中 + 1 偏移的大小为 a 中一个元素的大小，即 1 个 int 型的大小；

ptr - 1，由于强制类型转换，此时 - 1 偏移的大小为 1 个 int 型；

# 4
如果MyClass为一个类，执行”MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是()
A 2

B 5

C 4

D 9

解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，

但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。

# 5
以下代码的输出结果：

```c++
int__tmain(int argc,_TCHAR* argv[])
{
    int a[2][5]={{2,3,4,5,6},{7,8,9, 10,11}};
    int *ptr =(int*)(&a+1);
    cout <<*(ptr-3) << endl;
}
```
解析：

```c++
int main( ){
    int a[] [5] = { {1,2,3,4,5}，{6,7,8,9,10},{11,12,13,14,15}};
    int *p1 = (int*)(&a+1);//增量为整个二维数组大小[3][5]
    int *p2 = (int*) (a+1);//增量为第二维数组大小[1][5]
    int *p3 = (int*) (a[0] +1);//增量为sizeof( int)
    cout <<*( p1-3)<< '\t' <<*p2 << '\t' <<*p3 << '\n ';//13   6   2
    return 0;
}
```

# 6
派生类对象可以访问基类成员中的（）

A 公有继承的私有成员

B 私有继承的公有成员

C 公有继承的保护成员

D 

解析：

这道题问的是派生类对象，而不是派生类内部

基类成员在派生类的访问属性取决于继承方式以及这些成员本来在基类中的访问属性

+ 基类的私有成员无论什么继承方式，在派生类中均不可以直接访问
+ 在公有继承下，基类的保护成员和公有成员均保持原访问属性
+ 在保护继承方式下，基类的保护和公有成员在派生类的访问属性均为保护属性
+ 在私有继承下，基类的保护和公有成员在派生类中的访问属性均为私有属性

所以对于此题

1.公有继承的私有成员不被继承，所以不能访问

2.私有继承的公有成员可以被类的方法访问，不能被对象访问，属于私有属性

3.公有继承的保护成员具有保护属性，只能被类的方法访问，不能被对象访问

# 7
以下程序输出结果是____。
```c++
class A
{
public:
    virtual void func(int val = 1)
    { std::cout<<"A->"<<val <<std::endl;}
    virtual void test()
    { func();}
};
class B : public A
{
public:
    void func(int val=0)
{std::cout<<"B->"<<val <<std::endl;}
};
int main(int argc ,char* argv[])
{
    B*p = new B;
    p->test();
return 0;
}
```
A  A->0

B  B->1

C  A->1

D  B->0

E  编译出错

F  以上都不对

解析：

记住：virtual 函数是动态绑定，而缺省参数值却是静态绑定。

意思是你可能会在“调用一个定义于派生类内的virtual函数”的同时，却使用基类为它所指定的缺省参数值。

结论：绝不重新定义继承而来的缺省参数值！（可参考《EffectiveC++》条款37） 

对于本例： 

B*p = newB;

p->test();

p->test()执行过程理解： 

(1) 由于B类中没有覆盖（重写）基类中的虚函数test()，因此会调用基类A中的test()； 

(2) A中test()函数中继续调用虚函数fun()，因为虚函数执行动态绑定，p此时的动态类型（即目前所指对象的类型）为B*，

因此此时调用虚函数fun()时，执行的是B类中的fun()；所以先输出“B->”； 

(3)缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1，所以输出“1”； 

最终输出“B->1”。所以大家还是记住上述结论：绝不重新定义继承而来的缺省参数值！

# 8
c++定义一个空的类CTest,CTest没有定义任何成员变量和成员函数，在32位机器上，以下结论正确的有:

A.对该类求sizeof，结果为0。

B.给CTest添加构造函数，再对cTest求sizeof，结果为1．

C.给cTest添加虚函数，再对cTest求sizeof，结果为4.

D.给cTest添加虚函数，再对CTest求sizeof，结果为5.

解析：
空类的大小是1，在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。

具体来说，空类同样可以被实例化，并且每个实例在内存中都有独—无二的地址，

因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独—无二的内存地址。

当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

对于虚函数，其大小在32位机器上为4;64位机器上为8，因为有虚函数的类对象中都有一个虚函数表指针_vptr，其大小是4字节。

静态成员存放在静态存储区，不占用类的大小,普通函数也不占用类大小。

# 9
关于C++中的友元函数说法正确的是（)

A.友元函数需要通过对象或指针调用

B.友元函数是不能被继承的

C.友元函数没有this指针

D.友元函数破环了继承性机制

解析：

A、友元函数可以像普通函数一样直接调用，不需要通过对象或指针;

BC、友元函数不是成员函数，所以不能被继承，也同样没有this指针;

D、友元函数破坏的是封装性

