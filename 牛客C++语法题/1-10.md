# 1
1.对于下面代码段char *const name = new char[5];下面的语句中正确的是（）

A、name[3]='q'；

B、name="line";

C、name=new char[5];

D、name=new char('q');

解析：

name被定义常量指针，所以它所指的内容能改变，但指针本身的内容不可以修改。

name[3]='q'；"修改了name所指的内容，是正确的。

而"name="line"；"name= new char[5]；"和"name=new char（'q'）；"以不同的方法修改了常量指针，都是错误的。

# 2
2.【多选】以下哪些做法是不正确或者应该极力避免的：（ ）

A、构造函数声明为虚函数

B、派生关系中的基类析构函数声明为虚函数

C、构造函数中调用虚函数

D、析构函数中调用虚函数

解析：答案为：A、C、D。

+ 先析构子类再析构父类，如果父类析构函数有虚函数，会导致调用子类的已经析构的内容。

+ 先构造父亲类再构造子类，如果父类构造函数有虚函数，会导致调用子类还没构造的内容。

A选项：构造函数声明为虚函数，是不正确的做法。构造函数主要用于初始化对象的状态，而虚函数是在运行时动态绑定的，需要通过对象的虚函数表来查找实际需要调用的函数。

而对象的虚函数表在构造函数还没有执行完毕之前是无法初始化的，因此构造函数不能声明为虚函数。

B选项：派生关系中的基类析构函数声明为虚函数是正确的做法，这样就可以通过基类指针来正确地调用派生类对象的析构函数。

C选项：构造函数中调用虚函数是不正确的做法。在构造函数执行期间，对象尚未完全构造完成，只有当前类的成员变量已经初始化，而派生类的成员变量尚未初始化。

如果在构造函数中调用虚函数，会导致调用错误的函数或出现未定义的行为。

D选项：析构函数中调用虚函数是不正确的做法。对象的析构函数被调用时，对象已经开始撤销，即成员变量逐步被销毁，如果在析构函数中调用虚函数，

可能会调用当前对象已经被销毁的虚函数，引发未定义的行为。
