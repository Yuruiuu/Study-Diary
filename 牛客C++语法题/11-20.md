# 1
请阅读下面代码片段并且回答问题：
```c++
#define SIZE_20M (20*1024*1024)
void func_a()
{
    char *temp = malloc(SIZE_20M)
    return;
}
void func_b()
{
    char temp[SIZE_20M];
    //...do something using temp
    return;
}
```

关于这段代码，下列说法正确的是

A func_a 获得临时内存的方式效率通常更高。

B func_b 使用了太多的栈，程序可能会在运行时候崩溃。

C func_b 存在内存泄露

D func_a 和func_b 分配的内存会自动初始化0

解析： 

A  func_a()动态分配的数据位于堆区，func_b()的temp位于栈区，栈区的执行效率高于堆区，故func_b()效率高 

C  func_b()中没有动态分配的内存，不存在泄露问题 

D  都不会自动初始化为0，只有全局变量或者static变量会初始化为0 

B  栈的空间一般为2M，分配太多栈空间程序肯定会崩溃

# 2
3.
若char是一字节，int是4字节，指针类型是4字节，代码如下：
```c++
class CTest
{
    public:
        CTest():m_chData(‘\0’),m_nData(0)
        {
        }
        virtual void mem_fun(){}
    private:
        char m_chData;
        int m_nData;
        static char s_chData;
};
char CTest::s_chData=’\0’;
```
问：

（1）若按4字节对齐sizeof(CTest)的值是多少？

（2）若按1字节对齐sizeof(CTest)的值是多少？

请选择正确的答案。

A  16 4

B  16 10

C  12 9

D  10 10

解析：

1.类中一旦有virtual修饰的成员函数，编译器会构建虚函数表，在该类的对象中会存放一个指向虚函数表的指针，在 32位机中该指针和其他指针一样占用4字节。 +4 

2.static作为静态变量是对类而言的，为所有对象共有，不计算对象的占用空间。 +0 

3.什么都没有或仅有非虚成员函数的类或仅有类型声明的类(如typdef)，均为空类。

对于空类，编译器会构造占用1字节空间的变量(通常为char型); +1 ；

若该类为基类，则继承自空基类的子类不计算这1字节的空间，仅计算子类所占空间(编译器原理:空基类优化)。 +0 

4.对齐规则，如果注意了题目说明或代码开头的字节对齐宏:#pragma pack，对大家都没问题。

# 3
下面程序执行结果:
```c++
using namespace std;
class A{
    public:
        virtual void f() { cout << "A::f() "; }
        void f() const { cout << "A::f() const "; }
};
class B : public A {
    public:
        void f() { cout << "B::f() "; }
        void f() const { cout << "B::f() const "; }
};
void g(const A* a) {
    a->f();
}
int main(int argc, char *argv[]) {
    A* p = new B();
    p->f();
    g(p);
    delete(p);
    return 0;
}
```
A  B::f() B::f() const

B  B::f() A::f() const

C  A::f() B::f() const

D  A::f() A::f() const

解析：

 当基类指针指针指向派生类：
 
 a. 如果调用的成员函数在基类中定义为虚函数，在派生类中重写了（函数覆盖），则该成员函数指的是派生类中的；
 
 b. 相反如果未在基类中定义成为虚函数，则调用的函数其实是基类中的。 
 
   函数覆盖（多态）的条件：  
   
    1： 基类中的成员函数被virtual关键字声明为虚函数;      
    2：派生类中该函数必须和基类中函数的名称、参数类型和个数等完全一致;      
    3：将派生类的对象赋给基类指针或者引用，实现多态。     
  
   常量指针指向常对象, 常对象只能调用其常成员函数,因此通过g(const A* a)调用的是void f() const;

# 4
下面函数的输出结果是（）
```c++
void func() {
    int k = 1^(1 << 31 >> 31);
    printf("%d\n", k);
}
```
A  0

B  -1

C  -2

D  1

解析：

 (1 << 31 );左移31位，并在右侧填充0，得到0x80000000，即符号位为1，其他为0，即（-2147483648） 
 
 int k = 1^(1 << 31 >> 31);注意，这里在右移的时候，符号位保持为1，右移后填充1，结果为0xFFFFFFFF，即（-1）
  
 0x00000001^0xFFFFFFFF，即0xFFFFFFFE（-2）
