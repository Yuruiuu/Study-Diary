# 1
5.关于C++中的友元函数说法正确的是（      ）

A 友元函数只能访问所在类的保护成员和公有成员，不能访问私有成员

B 友元函数是不能被继承的

C 友元函数没有this指针

D 友元函数破环了继承性机制

正确答案：BC

解析：

友元函数是不能被继承的，可理解为：你父亲的朋友不一定是你自己的朋友 
 
this指针是指向当前对象的，可以访问当前对象的所有成员，而友元函数是非成员函数，没有this指针 
 
友元函数并没有破坏继承性机制，因为友元函数是非成员函数，并不会被继承，继承只是继承的成员函数及变量 
 
# 2

以下定义错误的是：

A struct A{A _a;};

B struct A{A* _a;};

C struct A{A& _a;};

D struct B; struct A{B& _b;}; struct B{A& _a;};
正确答案：A

解析：

struct成员类型不可以是它自己。 因为会递归定义。 

理论上这样导致结构体的大小不能被计算（无限大小）。所以不能在结构体里的成员类型是结构体本身。 

但是成员可以定义为该结构体的指针。就像你上面这段代码。因为指针的大小是已知的（随编译器和操作系统而定）。 

所以可以定义为该结构体的指针，但不是该结构体。

# 3
下面程序执行结果:
```c++
using namespace std;
class A{
    public:
        virtual void f() { cout << "A::f() "; }
        void f() const { cout << "A::f() const "; }
};
class B : public A {
    public:
        void f() { cout << "B::f() "; }
        void f() const { cout << "B::f() const "; }
};
void g(const A* a) {
    a->f();
}
int main(int argc, char *argv[]) {
    A* p = new B();
    p->f();
    g(p);
    delete(p);
    return 0;
}
```
A B::f() B::f() const

B B::f() A::f() const

C A::f() B::f() const

D A::f() A::f() const

解析：B

（1）当基类函数为虚函数时，派生类重写此虚函数可以不加virtual，所以对于p->f(); 基类指针指向派生类，函数f()在基类和派生类皆为虚，故动态编联指向派生类；

（2）第二部分实际是 const A* a = new B(); 本质还是基类指针指向派生类，并且由于a为常指针，只能指向常函数，所以肯定是调用f() const；

具体调用基类还是派生类中的f() const;呢？由于此const函数在基类和派生类中都不是虚函数，所以采用静态编联，

p->f() const 根据指针类型(A)调用A::f() const，调用基类的f() const;

# 3
已知int a[3][4];则下列能表示a[1][2]元素值的是()

```c++
A  *(*(a+1) + 2 )

B  *(a+1+2)

C  (&a[0]+1)[2]

D  *(a[0]+1)
 ```

解析：A 

在数组中，数组名是第一个数组的地址. 注意这里a不是第一个元素的地址,而是第一个维数组的地址,a[0][0]才是表示的一维数组第一个元素的地址. 地址 + 1表示向下移一层.

C选项 (&a[0]+1) +1加的是一个a[0]的步长，(&a[0]+1)[2]其实是数组a[3]的地址，改成((int*)(&a[0]+1))[2] 才是对的 

# 4
在 gcc 环境下，已知数组 int arr[5]={1,2,3,4,5}; 则 *(*(&arr+1)-1) 的结果为

A  1

B  0

C  4

D  5

解析：D

&arr是二级指针，给arr加行变成二维数组arr[][5], &arr+1是arr[1][0]， (* (&arr+1)-1))是arr[0][4]， 所以*(* (&arr+1)-1))是5

# 5
若有如下程序：
```c++
int main() {
    int y=3,x=3,z=1;
    printf("%d%d\n",(++x, y++), z+2);
}
```
运行该程序的输出结果是（）

A  34

B  42

C  43

D  33

解析：D

z+2值为3，3入栈。 y为3，3入栈，y自增为4。 出栈输出:33 

逗号表达的求值顺序是从左向右以此计算用逗号分隔的各表达式的值，

最后一个表达式的值就是整个逗号表达式的值，所以（++x，y++）的值将是y++，

因为是先输出y的值，再将y增1，所以首先输出3，再输出Z+2的值，即3；所以应选择D
 
