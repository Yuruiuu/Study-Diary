# 1
5.关于C++中的友元函数说法正确的是（      ）

A 友元函数只能访问所在类的保护成员和公有成员，不能访问私有成员

B 友元函数是不能被继承的

C 友元函数没有this指针

D 友元函数破环了继承性机制

正确答案：BC

解析：

友元函数是不能被继承的，可理解为：你父亲的朋友不一定是你自己的朋友 
 
this指针是指向当前对象的，可以访问当前对象的所有成员，而友元函数是非成员函数，没有this指针 
 
友元函数并没有破坏继承性机制，因为友元函数是非成员函数，并不会被继承，继承只是继承的成员函数及变量 
 
# 2

以下定义错误的是：

A struct A{A _a;};

B struct A{A* _a;};

C struct A{A& _a;};

D struct B; struct A{B& _b;}; struct B{A& _a;};
正确答案：A

解析：

struct成员类型不可以是它自己。 因为会递归定义。 

理论上这样导致结构体的大小不能被计算（无限大小）。所以不能在结构体里的成员类型是结构体本身。 

但是成员可以定义为该结构体的指针。就像你上面这段代码。因为指针的大小是已知的（随编译器和操作系统而定）。 

所以可以定义为该结构体的指针，但不是该结构体。

# 3
下面程序执行结果:
```c++
using namespace std;
class A{
    public:
        virtual void f() { cout << "A::f() "; }
        void f() const { cout << "A::f() const "; }
};
class B : public A {
    public:
        void f() { cout << "B::f() "; }
        void f() const { cout << "B::f() const "; }
};
void g(const A* a) {
    a->f();
}
int main(int argc, char *argv[]) {
    A* p = new B();
    p->f();
    g(p);
    delete(p);
    return 0;
}
```
A B::f() B::f() const

B B::f() A::f() const

C A::f() B::f() const

D A::f() A::f() const

解析：B

（1）当基类函数为虚函数时，派生类重写此虚函数可以不加virtual，所以对于p->f(); 基类指针指向派生类，函数f()在基类和派生类皆为虚，故动态编联指向派生类；

（2）第二部分实际是 const A* a = new B(); 本质还是基类指针指向派生类，并且由于a为常指针，只能指向常函数，所以肯定是调用f() const；

具体调用基类还是派生类中的f() const;呢？由于此const函数在基类和派生类中都不是虚函数，所以采用静态编联，

p->f() const 根据指针类型(A)调用A::f() const，调用基类的f() const;

# 3
已知int a[3][4];则下列能表示a[1][2]元素值的是()

```c++
A  *(*(a+1) + 2 )

B  *(a+1+2)

C  (&a[0]+1)[2]

D  *(a[0]+1)
 ```

解析：A 

在数组中，数组名是第一个数组的地址. 注意这里a不是第一个元素的地址,而是第一个维数组的地址,a[0][0]才是表示的一维数组第一个元素的地址. 地址 + 1表示向下移一层.

C选项 (&a[0]+1) +1加的是一个a[0]的步长，(&a[0]+1)[2]其实是数组a[3]的地址，改成((int*)(&a[0]+1))[2] 才是对的 

# 4
在 gcc 环境下，已知数组 int arr[5]={1,2,3,4,5}; 则 *(*(&arr+1)-1) 的结果为

A  1

B  0

C  4

D  5

解析：D

&arr是二级指针，给arr加行变成二维数组arr[][5], &arr+1是arr[1][0]， (* (&arr+1)-1))是arr[0][4]， 所以*(* (&arr+1)-1))是5

# 5
若有如下程序：
```c++
int main() {
    int y=3,x=3,z=1;
    printf("%d%d\n",(++x, y++), z+2);
}
```
运行该程序的输出结果是（）

A  34

B  42

C  43

D  33

解析：D

z+2值为3，3入栈。 y为3，3入栈，y自增为4。 出栈输出:33 

逗号表达的求值顺序是从左向右以此计算用逗号分隔的各表达式的值，

最后一个表达式的值就是整个逗号表达式的值，所以（++x，y++）的值将是y++，

因为是先输出y的值，再将y增1，所以首先输出3，再输出Z+2的值，即3；所以应选择D
 
# 6
在下面的类定义中，横线上应填入的内容是（）(注意，count是在类外了)
```c++
class Fred {
public:
    void print() {
        cout << data << endl;
    }
    void setData(double d) {
        data = d;
    }
    static int count;
private:
    double data;
};
__________count = 0;
```

A  static int Fred::

B  int Fred::

C  int

D  static int

解析：B

在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样 
```c++
class A
{ 
private: 
      static int count ; // 类内声明 
}; 
int A::count = 0 ; // 类外初始化，不必再加static关键字 
```
为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 
 
这样不行
```c++
class A
{ 
private: 
    static int count = 0; // 静态成员不能在类内初始化 
};
```
但是这样可以 
```c++
class A
{ 
private: 
    static const int count = 0; // 静态常量成员可以在类内初始化 
};
```
结论： 

+ 静态常量数据成员可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化；    
+ 静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化；    
+ 非静态的常量数据成员常量成员是可以直接在类内初始化的，或者使用初始化列表, 不能在构造函数中初始化;  
+ 非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化； 

 # 7
 下面哪些函数不能被声明为虚函数（      ）

A  构造函数

B  静态成员函数

C  内联函数

D  友元函数

解析：ABCD

不能声明为虚函数的函数

1. 普通函数（非成员函数）：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在编译时就绑定了它。
2. 静态成员函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它也没有动态绑定的必要。,
3. 内联成员函数：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在编译时被展开，而虚函数在运行时才动态绑定。
4. 构造函数：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作？？
 5. 友元函数：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。 
 
注意：友元本身可以是虚函数！！

如果一个类的友元函数是另一个类成员函数，那么它在自己的类内可以被声明为虚函数。

# 8
下面程序执行输出结果为（）
```c++
#include <stdio.h>
int fun(int i) {
    int cnt = 0;
    while(i) {
        cnt++;
        i = i&(i-1);
    }
    return cnt;
}
 
int main() {
    printf("%d\n", fun(2017));
    return 0;
}
```
A  6

B  7

C  8

D  9

解析：B

  i = i & (i-1)，统计i二进制中有多少个1 
 
  i = i | (i+1)，统计i二进制中有多少个0
  
对于本题
  
  2017的二进制是11111100001，有7个1 
 
  n&(n-1)就是从右往左数1的个数
 
  第一步：刚开始n=11111100001!=0,count=1,n=11111100001&11111100000=11111100000,最右边第一个1 
 
  第二步：n!=0，n=11111100000&11111011111=11111000000,最右边第二个1 
 
  …… 
 
  以此类推 

# 9
下列程序的输出结果是（ ）
```c++
int main() {
    int a = 011;
    printf("%d\n", ++a);
}
```

A  12

B  11

C  10

D  9

解析：C

0开头是八进制，011是9，9++是10

# 10
已知int x=5;，执行下列语句后，x的值为（）

x += x -= x*x;

A  25

B  40

C  –40

D  20

解析：

先算x-＝x*x，得出x=5-5*5,x=-20;再算x+=x;得出x=-20-20,x=-40
